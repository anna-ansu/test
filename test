https://habr.com/ru/post/351982/ Matthias Noback Об Идеальной Архитектуре — Слои, Порты и Адаптеры(Часть 2 — Слои)
https://m.habr.com/ru/post/352700/ Matthias Noback Об Идеальной Архитектуре — Слои, Порты и Адаптеры (Часть 3 — Порты и Адаптеры)
https://github.com/ferrius/ddd-cqrs-example/ This is an example of implementation and my vision of practical CQRS, DDD, ADR, hexagonal architecture and directory structure.
https://github.com/ferrius/ddd-cqrs-example/blob/master/depfile.yaml Deptrac depfile.yaml example
https://github.com/YaFou/symfony-clean-architecture-skeleton/ Symfony Clean Architecture Skeleton

include:
    -   component: ....docker-up-down


stages:
    - deploy

variables:
    APP_ENV: prod
    APP_DEBUG: 0
    DOCKER_IMAGE: "registry....nameProject:$CI_COMMIT_BRANCH"
    

workflow:
    rules:
        -   if: $CI_COMMIT_REF_NAME == "main"
            variables:
                APP_ENV: prod
                SERVER_NAME: nameProject.nameServer
                TAG: tag

up:
    environment:
        name: "$TAG"
    script:
        - docker compose pull
        - docker compose up ${SERVICES_NAME} -d
down:
    environment:
        name: "$TAG"



FROM .. php:8-4
COPY . /app/

# RUN mv "$PHP_INI_DIR/php.ini-production" "$PHP_INI_DIR/php.ini" && \
RUN mv "/app/build/docker-entrypoint.sh" "/usr/local/bin/docker-entrypoint" && \
    chmod 755 /usr/local/bin/docker-entrypoint && \
    rm -Rf build/ && \
    set -eux && \
	mkdir -p var/cache var/log files && \
	chmod +x bin/console; sync && \
    php bin/console cache:clear --env=prod


CMD ["php", "-S", "localhost:80", "-t", "public"]


docker-entrypoint.sh - 

set -e

if [ "$1" = 'php' ] || [ "$1" = 'bin/console' ]; then
    if [ "$( find ./migrations -iname '*.php' -print -quit )" ]; then
        php bin/console doctrine:migrations:migrate --no-interaction
    fi
fi

exec docker-php-entrypoint "$@"



SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have
'-rwxr-xr-x' permissions. It is recommended to double check and reset permissions for sensitive files and directories.
Recreating symfony-test-php ... done
Exception ignored in: <function Popen.__del__ at 0x0000024469D194C0>
Traceback (most recent call last):
  File "subprocess.py", line 1051, in __del__
  File "subprocess.py", line 1453, in _internal_poll
OSError: [WinError 6] Неверный дескриптор

$ docker build -t $DOCKER_IMAGE .
ERROR: "docker buildx build" requires exactly 1 argument.
See 'docker buildx build --help'.
Usage:  docker buildx build [OPTIONS] PATH | URL | -
Start a build
Cleaning up project directory and file based variables
00:01
ERROR: Job failed: exit code 1


private WorkflowInterface $synchronizationWithCFStateMachine,

 private function applyTransitionToBatch(iterable $bs, string $transition): void
    {
        foreach ($bs as $b) {
            if ($this->synchronizationWithCFStateMachine->can($b, $transition)) {
                $this->synchronizationWithCFStateMachine->apply($b, $transition);
            } else {
                $this->logger->warning(
                    'Transition {transition} not allowed for bankrupt {id}',
                    ['transition' => $transition, 'id' => $b->getId()]
                );
            }
        }
    }

$this->synchronizationWithCFStateMachine->apply($b, 'ToSynchronized');


private function applyTransitionToBatch(iterable $bs, string $transition): void
{
    foreach ($bs as $b) {
        if ($this->synchronizationWithCFStateMachine->can($b, $transition)) {
            $this->synchronizationWithCFStateMachine->apply($b, $transition);
            $this->entityManager->persist($b); // готовим к сохранению
        } else {
            $this->logger->warning(
                'Transition {transition} not allowed for bankrupt {id}',
                ['transition' => $transition, 'id' => $b->getId()]
            );
        }
    }

    // сохраняем пачкой, а не по одному
    $this->entityManager->flush();
}


$i = 0;
foreach ($bs as $b) {
    if ($this->synchronizationWithCFStateMachine->can($b, $transition)) {
        $this->synchronizationWithCFStateMachine->apply($b, $transition);
        $this->entityManager->persist($b);
    }

    if (($i % 1000) === 0) { // каждые 1000 штук
        $this->entityManager->flush();
        $this->entityManager->clear();
    }
    $i++;
}

$this->entityManager->flush();
$this->entityManager->clear();



<?php

use AltchaOrg\Altcha\Altcha;
use AltchaOrg\Altcha\BaseChallengeOptions;
use AltchaOrg\Altcha\Challenge;
use AltchaOrg\Altcha\ChallengeOptions;
use AltchaOrg\Altcha\Hasher\Algorithm;
use AltchaOrg\Altcha\Hasher\Hasher;
use AltchaOrg\Altcha\Solution;
use PHPUnit\Framework\TestCase;
use Codeception\Util\Debug;
use Codeception\Test\Unit;  
use DateInterval;
use DateTimeImmutable;

/**
 * @group altcha
 */
class AltchaTest extends TestCase
{
    /** @var UnitTester */
    protected $tester;
    
    /** @var Hasher */
    private static Hasher $hasher;
    
    /** @var Altcha */
    private static Altcha $altcha;
    
    /** @var Challenge */
    private static Challenge $challenge;

    public static function setUpBeforeClass(): void
    {
        // build a default challenge for all tests (for performance reasons)
        self::$hasher = new Hasher();
        self::$altcha = new Altcha('test-key', self::$hasher);
        self::$challenge = self::$altcha->createChallenge();
    }

    public function testCreateChallenge(): void
    {
        self::assertEquals(Algorithm::SHA256, self::$challenge->algorithm);
        self::assertNotEmpty(self::$challenge->challenge);
        self::assertEquals(BaseChallengeOptions::DEFAULT_MAX_NUMBER, self::$challenge->maxNumber);
        self::assertNotEmpty(self::$challenge->salt);
        self::assertNotEmpty(self::$challenge->signature);
    }

    public function testVerifyFieldsHash(): void
    {
        $formData = [
            'field1' => 'value1',
            'field2' => 'value2',
        ];

        $fields = ['field1', 'field2'];
        $fieldsHash = '1e823fb92790112edaa34e8cfed2afbb86054153932d8c2796d2c62727d287a6';

        $isValid = self::$altcha->verifyFieldsHash($formData, $fields, $fieldsHash, Algorithm::SHA256);

        self::assertTrue($isValid);
    }

    public function testSolveChallenge(): void
    {
        $solution = self::$altcha->solveChallenge(
            self::$challenge->challenge,
            self::$challenge->salt,
            Algorithm::from(self::$challenge->algorithm),
            self::$challenge->maxNumber
        );

        self::assertInstanceOf(Solution::class, $solution);
        self::assertEquals($solution->number, $solution->number);
        self::assertGreaterThan(0, $solution->took);
    }

    public function testInvalidSolveChallenge(): void
    {
        $solution = self::$altcha->solveChallenge(
            'asd',
            self::$challenge->salt,
            Algorithm::from(self::$challenge->algorithm),
            self::$challenge->maxNumber
        );

        self::assertNull($solution);
    }

    public function testVerifySolution(): void
    {
        $solution = self::$altcha->solveChallenge(
            self::$challenge->challenge,
            self::$challenge->salt,
            Algorithm::from(self::$challenge->algorithm),
            self::$challenge->maxNumber
        );

        self::assertInstanceOf(Solution::class, $solution);

        $payload = [
            'algorithm' => self::$challenge->algorithm,
            'challenge' => self::$challenge->challenge,
            'salt' => self::$challenge->salt,
            'signature' => self::$challenge->signature,
            'number' => $solution->number,
        ];

        $isValid = self::$altcha->verifySolution(base64_encode(json_encode($payload) ?: ''));

        self::assertTrue($isValid);
    }

    public function testVerifyServerSignature(): void
    {
        $algorithm = Algorithm::SHA256;
        $expires = (new DateTimeImmutable())->add(new DateInterval('PT10S'));
        $verificationData = 'verified=1&expire=' . $expires->getTimestamp();

        $hash = self::$hasher->hash($algorithm, $verificationData);
        $signature = self::$hasher->hashHmacHex($algorithm, $hash, 'test-key');

        $result = self::$altcha->verifyServerSignature([
            'algorithm' => $algorithm,
            'verificationData' => $verificationData,
            'signature' => $signature,
            'verified' => true,
        ]);

        self::assertTrue($result->verified);
    }

    public function testVerifyCustomOptions(): void
    {
        $maxNumber = 100;
        $algorithm = Algorithm::SHA1;

        $challenge = self::$altcha->createChallenge(
            new ChallengeOptions(
                $algorithm,                                 // algorithm
                $maxNumber,                                 // maxNumber
                (new DateTimeImmutable())->add(
                    new DateInterval('PT10S')
                ),                                          // expires
                ['custom_param' => '123']                   // params
                // salt и number заполняются внутри Altcha
            )
        );

        $solution = self::$altcha->solveChallenge(
            $challenge->challenge,
            $challenge->salt,
            $algorithm,
            $maxNumber,
        );

        self::assertInstanceOf(Solution::class, $solution);

        $isValid = self::$altcha->verifySolution([
            'algorithm' => $algorithm,
            'challenge' => $challenge->challenge,
            'salt' => $challenge->salt,
            'signature' => $challenge->signature,
            'number' => $solution->number,
        ]);

        self::assertTrue($isValid);
    }
